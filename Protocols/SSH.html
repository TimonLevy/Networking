<head>
    <link rel="stylesheet" type="text/css" href="../Misc/myStyle.css">
</head>

<body>
<div id="SShTitle">
<h1>Secure Shell A.K.A SSH</h1>
<tags>[#Layer-7] [#TCP/22]</tags>
</div>
<div id="SSHSummary">
SSH was conceptualized as a secure replacement for the telnet protocol. The SSH protocol allows a user to remotely interface with another machine on the internet with their communication secured.

<h3>WHY WAS IT INVENTED?</h3>
The protocol was invented by Tatu Ylönen after he found a password sniffer on his university's network. Since the prominent remote managment protocol back then was Telnet, all communications appeared as cleartext on the wire. That pushed Tatu to design the first version of the protocol all the way back in 1995.

<h3>HOW DOES IT WORK</h3>
SSH is actually a suite of SSH protocols riding on TCP, each playing a key part in the role of remote managment. Those protocols are:

<b><label>SSH Transport layer Protocol</label></b>
Provides server authentication, message integrity, compression and data confidentiality. (encryption)

<b><label>SSH User Authentication protocol</label></b>
Provides user authentication services.

<b><label>SSH Connection Protocol</label></b>
Allows multiplexing a single connection to multiple logical channels.

<div class="drawing"><div class="drawing-content">
  ______________________________________
 /                 /                   /|
/_________________/___________________/ |
|  SSH USER AUTH  |  SSH CONNECTION   | |
|    PROTOCOL     |     PROTOCOL      | /
|_________________|___________________|/.
 /                                     /|
/_____________________________________/ |
|                                     | |
|    SSH TRANSPORT LAYER PROTOCOL     | /
|_____________________________________|/.
 /                                     /|
/_____________________________________/ |
|                                     | |
|    TRANSMISSION CONTROL PROTOCOL    | /
|_____________________________________|/
</div></div>

The protocol is very useful and is the default remote management tool for linux based machines. The shell that the protocl provides interactibility with the file system and processes in a very comfortable fashion.

</div>
<div id="SSHKeyExchange">
<h4>CONNECTION INITIALIZATION & KEY EXCHANGE</h4>

Since I want to draw another diagram I will do this in a code box. Let's try       
and do this simply step by step. The client will want to initiate a connection.    
The client will send an 'Identification String Exchange' message, to               
synchronize the SSH version. The server will return the same message.              
                                                                                
Afterwards comes the `Key Exchange Initialization` message, just like in TLS       
the client and server will send their ciphers in preffered order and more          
parameters that the exchange requires like hashing & compression algorithms.       
Both client and server will do this at about the same time.                        
                                                                                
After agreeing on a cipher, hashing & compression algorithm the client will send   
an `ECDH Key Exchange Initialization` message to start a diffie hellman Key        
Exchange procedure. In this step both client and server will generate the same key 
using emphereal public and private they create and send eachother. They will also  
sign all of their messages up until now together with their emphereal public key   
and the secret key as a hash, the server will sign their hash with their private   
rsa key.                                                                           
                                                                                
First the server has to accept the server's public rsa key, either by a certificate
or a `public key database`. If bot of those don't succeed the client can decide    
wether to accept the conection or not.                                             
                                                                                
The client can decrypt then hash with the server's public rsa key and              
match the server's hash to a hash they generate themselves the exact same way.     
That way the client proves both the server has the same key and that the server is 
the server.                                                                        
                                                                                
The client and sever will not actually communicate with the shared secret key, they
will use that key to derive 6 new keys. 2 keys for `encryption`, 2 keys as `Init   
Vectors`, 2 keys for `Integrity` (like, SSL MAC). the client will send an encrypted
`New Keys`.                                                                        
                                                                                
And to end it, the client send an `SSH_MSG_SERVICE_REQUEST` message to ask for the 
authentication service. The server will return an `SSH_MSG_SERVICE_ACCEPT` response
and the user will be allowed to log in.                                            

<div class="drawing"><div class="drawing-content">
C                                 S
│ Identification String Exchange  │
│ ──────────────────────────────► │
│ ◄────────────────────────────── │
│                                 │
│   Key Exchange Initialization   │
│ ──────────────────────────────► │
│ ◄────────────────────────────── │
│                                 │
│     ECDH Key Exchange Init      │
│ ──────────────────────────────► │
│     ECDH Key Exchange Reply     │
│ ◄────────────────────────────── │
│                                 │
│             New Keys            │
│ ──────────────────────────────► │
│     SSH_MSG_SERVICE_REQUEST     │
│ ──────────────────────────────► │
│     SSH_MSG_SERVICE_ACCEPT      │
│ ◄────────────────────────────── │
V                                 V
</div></div></div>

<div id="SSHTransport">
<h4>SSH Transport Layer Protocol</h4>
<b><label>Integrity, Compression, and Confidentiality of data</label></b>
Here is a diagram to explain how the protocol does all of the above:
<div class="drawing">
<div class="drawing-content">
seq# - packet sequence no.     ┌────────────────────SSH─PACKET────────────────────┐
pktl - packet len              ├──────────────────2.MAC─────────────────────┐     │
pdl  - padding len             │      ┌─────────────1.ENCRYPTED─────────────┤     │
┌─────────────────┐            ┌──────┬──────┬─────┬──────────────┬─────────┬─────┐
│     PAYLOAD     │            │ seq# │ pktl │ pdl │ CMPRSSD PYLD │ padding │ MAC │
└─────────────────┘            └──────┴──────┴─────┴──────────────┴─────────┴─────┘
         └─────────────────────────────────────────────────┘
</div></div>

<b><label>Saving Host Keys</label></b>
This protocol needs to save the host keys that he different hosts (clients) connecetd to the ssh'd machine (server).
It can do that by relying on a CA and matching client Certificates, or just keeping them in an internal Database.

<b><label>Key Generation</label></b>
The protocol is also responsible for the key generation, that is generate the 6 keys from the exchanged secret key.
The key exchange intself is also done by the `SSH Transport Layer Protocol`.
</div>
<div id="SSHAuthentication">
<h4>SSH User Authentication Protocol</h4>
This protocol role is to authenticate users wanting to connect to the server. The client sends an authentication request message with the username credential. The server will then offer the client authentication methods:
* Password - client inputs a password, the password in encrypted in transit.
* Public Key - client authenticates themselves using their public key.
* Host Based - client authenticates themselves using a central host (Like a DC).

The client may authenticate themselves by any of these methods, the protocol will return a success response and authenticate the user. Or if the authentication is not enough, the server may ask the client to further authenticate themselves.
</div>
<div id="SSHConnection">
<h4>SSH Connection Protocol</h4>
This protocol rides ontop of the `SSH Transport Layer Protocol`. The protocol is responsible for many of the things that make SSH so great.

<b><label>Multiplexing</label></b>
This protocol is responsible for opening and closing channels for concurrent data transfer, there are 4 types of channels:
* Session - used in remote execution of a program (like the shell), file transfer, etc.
* X11 - Used to send desktop interface to remote machines, for applications that show graphical interface of the server machine.
* forwarded-tcpip - remote port forwarding, we will get to that in a second.
* direct-tcpip - local port forwarding.

<b><label>Port forwarding</label></b>
SSH enables port forwarding on an encrypted ssh tunnel to protect communication, SSH allows both remote and local port forwarding.
* local - local port forwarding let's an applicaiton forward a port onto ssh directly onto a port of the server.
* remote - remote port forwarding let's an application forward information on the ssh tunnel to an intermediate server (like a firewall) that will send the information to the ssh client on the server.

Remote port forwarding is used when direct communication to the server is impossible, for example when there is a firewall. The `SSH client` on the client machine will `encrypt the data` and the `ssh server` on the server machine will `decrypt the data` before forwaring it to the server application.
</div>

<diff>- (Started checking this protocol but you wrote too much information summaries it)</diff>
</body>